#
# Validate that STOP SLAVE works in a timely manner on a parallel replica with
# ROW binary logging format.
#
--source include/have_debug.inc
--source include/master-slave.inc
--source include/have_innodb.inc
--source include/have_binlog_format_row.inc

--echo #
--echo # Setup
--connection slave
--source include/stop_slave.inc
--let $old_debug= `SELECT @@global.debug_dbug`
--let $old_threads= `SELECT @@global.slave_parallel_threads`
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
--source include/start_slave.inc

--echo #
--echo # Initialize test data
--connection master
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');
--let $old_binlog_direct= `SELECT @@global.binlog_direct_non_transactional_updates`
SET @@global.binlog_direct_non_transactional_updates= 0;
SET @@session.binlog_direct_non_transactional_updates= 0;


# Needed by this test and include/rpl_par_stop_slave_quick.inc
create table ti (a int) engine=innodb;
create table tm (a int) engine=myisam;
--let $ti_ctr= 100
--let $tm_ctr= 200
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--sync_slave_with_master

--echo # Run binlog format independent test cases
--source include/rpl_par_stop_slave_quick_common.test

--echo #
--echo # ROW Test Case 1:
--echo # Using an N multi-statement transaction, ensure if STOP SLAVE is
--echo # issued in-between row updates, that the transaction is finished.
--echo #
--echo # This validation is easy actually, just assert the rows exist.
--echo #  BUT we need to test that the modified_non_trans_table flag is set

--connection master
truncate table ti;
truncate table tm;
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--sync_slave_with_master

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm) t`

--connection master

--echo # Next-to-commit non-transactional transaction should finish
--eval update tm set a=a+1
--source include/save_master_gtid.inc
--let $master_gtid_after_update= `select @@global.gtid_binlog_pos`

--echo # This should not be committed because it is after next-to-commit
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
set @@global.debug_dbug="+d,stop_slave_between_rows";

START SLAVE;
--source include/sync_with_master_gtid.inc

--echo # STOP SLAVE happens programmatically from stop_slave_between_rows
--source include/wait_for_slave_sql_to_stop.inc

--echo # Slave should be error-free
let $last_error = query_get_value("SHOW SLAVE STATUS", Last_SQL_Errno, 1);
--let $assert_text= Slave should be error free
--let $assert_cond= $last_error = 0
--source include/assert.inc

set @@global.debug_dbug="-d,stop_slave_between_rows";
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # ROW Test Case 2:
--echo # Using a T multi-statement transaction, ensure if STOP SLAVE is
--echo # issued in-between row updates, that the transaction is ROLLED BACK.

--connection master
truncate table ti;
truncate table tm;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--sync_slave_with_master

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm) t`

--connection master

--echo # Next-to-commit transactional multi-row event should be rolled back
--source include/save_master_gtid.inc
--let $master_gtid_initial= `select @@global.gtid_binlog_pos`
--eval update ti set a=a+1

--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
set @@global.debug_dbug="+d,stop_slave_between_rows";
START SLAVE;
--source include/sync_with_master_gtid.inc

--echo # STOP SLAVE happens programmatically from stop_slave_between_rows
--source include/wait_for_slave_sql_to_stop.inc

--let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm) t`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= No new rows should have been inserted
--let $assert_cond= $row_count_diff = 0
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
--echo # Comparing master gtid $master_pos to slaves $slave_gtid
--let $assert_text= No transactions should have committed
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

--echo # Slave should be error-free
let $last_error = query_get_value("SHOW SLAVE STATUS", Last_SQL_Errno, 1);
--let $assert_text= Slave should be error free
--let $assert_cond= $last_error = 0
--source include/assert.inc

set @@global.debug_dbug="-d,stop_slave_between_rows";
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Cleanup
--connection master
DROP TABLE ti, tm;
--eval SET @@global.binlog_direct_non_transactional_updates= $old_binlog_direct
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
--eval set @@global.debug_dbug="$old_debug"
--eval set @@global.slave_parallel_threads=$old_threads
--source include/start_slave.inc

--source include/rpl_end.inc

--echo # End of tests


#
# Validate that STOP SLAVE works in a timely manner on a parallel replica with
# ROW binary logging format.
#
--source include/have_debug.inc
--source include/master-slave.inc
--source include/have_innodb.inc
--source include/have_binlog_format_statement.inc

--echo #
--echo # Setup
--connection slave
--source include/stop_slave.inc
--let $old_threads= `SELECT @@global.slave_parallel_threads`
--let $old_domain_threads= `SELECT @@global.slave_domain_parallel_threads`
--let $old_slave_mode= `SELECT @@global.slave_parallel_mode`
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
change master to master_use_gtid=slave_pos;
--source include/start_slave.inc

--echo #
--echo # Initialize test data
--connection master
set statement sql_log_bin=0 for call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');
--let $old_binlog_direct= `SELECT @@global.binlog_direct_non_transactional_updates`
SET @@global.binlog_direct_non_transactional_updates= 0;
SET @@session.binlog_direct_non_transactional_updates= 0;
create table ti (a int) engine=innodb;
create table ti2 (a int) engine=innodb;
create table tm (a int) engine=myisam;
create table tm2 (a int) engine=myisam;
--let $ti_ctr= 100
--let $tm_ctr= 200
--let $tm2_ctr= 300
--let $ti2_ctr= 400
--sync_slave_with_master

--echo # Run binlog format independent test cases
--source include/rpl_par_stop_slave_quick_common.test


--echo #
--echo # Statement Test Case 1:
--echo # Using one parallel replication worker thread on workload {N,T}, ensure
--echo # the replica finishes the non-transactional transaction, and does not
--echo # start the next

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from tm2) t`

--connection master
BEGIN;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--eval insert into tm2 values ($tm2_ctr)
--inc $tm_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
COMMIT;
--source include/save_master_gtid.inc

--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
lock tables tm2 write;
START SLAVE;

--echo # Wait for replica to get stuck on held lock
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE;

--connection slave
--echo # Unlock row-level lock holding transaction
UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from tm2) t`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= Transaction should have committed
--let $assert_cond= $row_count_diff = 4
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
# N is the non-transactional transaction
--let $assert_text= N should have been applied
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

--echo # Slave should be error-free
let $last_error = query_get_value("SHOW SLAVE STATUS", Last_SQL_Errno, 1);
--let $assert_text= Slave should be error free
--let $assert_cond= $last_error = 0
--source include/assert.inc

--connection master
--source include/save_master_gtid.inc

--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Statement Test Case 2:
--echo # If STOP SLAVE is issued on a parallel slave, such that the next to
--echo # commit transaction is T; if the next event from the group will commit
--echo # the transaction (e.g. XID_EVENT), it should be allowed to complete.

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm) t`

--connection master
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--let $master_gtid_cmp= `select @@global.gtid_binlog_pos`
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--source include/save_master_gtid.inc

--connection slave
LOCK TABLES ti WRITE;
--source include/start_slave.inc

--echo # Wait for replica to begin executing the first transaction
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE;

--connection slave
UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm) t`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= No insertions should have committed
--let $assert_cond= $row_count_diff = 1
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= GTID slave state should increment to the first transaction
--let $assert_cond= $master_gtid_cmp = $slave_gtid
--source include/assert.inc

--source include/start_slave.inc
--source include/sync_with_master_gtid.inc

--echo #
--echo # Statement Test Case 3:
--echo # When a parallel replica has more than one parallel thread, if a later,
--echo # concurrent transaction is applying non-transactional transactions
--echo # while STOP SLAVE is issued, it should attempt to be rolled back and
--echo # an appropriate error message should be output.

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=2;
set @@global.slave_parallel_mode=AGGRESSIVE;
set @@global.slave_domain_parallel_threads=2;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from ti2 UNION ALL select * from tm2) t`

# Used to analyze events from just this test case by mysqlbinlog
let $slave_binlog_file= query_get_value("SHOW MASTER STATUS", File, 1);
let $init_slave_binlog_pos= query_get_value("SHOW MASTER STATUS", Position, 1);

--connection master
--eval insert into ti2 values ($ti2_ctr)
--inc $ti2_ctr
--let $pre_rollback_gtid= `SELECT @@global.gtid_binlog_pos`
BEGIN;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--eval insert into tm2 values ($tm2_ctr)
--inc $tm_ctr
--eval insert into ti2 values ($ti2_ctr)
--inc $ti2_ctr
--eval insert into ti2 values ($ti2_ctr)
--inc $ti2_ctr
COMMIT;
--source include/save_master_gtid.inc

--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
lock tables ti2 write;
START SLAVE;

--echo # Wait for both transactions to get stuck on lock
--connection slave
--let $wait_condition= SELECT count(*)=2 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE;

--connection slave
UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from ti2 UNION ALL select * from tm2) t`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= Three rows should have been added, one from the first T transaction, plus two for the N statements in the second transactions
--let $assert_cond= $row_count_diff = 3
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= Later transaction should not have been committed
--let $assert_cond= $pre_rollback_gtid = $slave_gtid
--source include/assert.inc

--echo # Wait for slave error
--let $slave_sql_errno= 1593
--source include/wait_for_slave_sql_error.inc

--connection slave
let $end_slave_binlog_pos= query_get_value("SHOW MASTER STATUS", Position, 1);
let $MYSQLD_DATADIR= `select @@datadir`;
--let $mysqlbinlog_out= $MYSQLTEST_VARDIR/tmp/binlog_events.out
flush logs;
--echo #MYSQL_BINLOG --start-position=init_slave_binlog_pos --stop-position=end_slave_binlog_pos MYSQLD_DATADIR/slave_binlog_file > mysqlbinlog_out
--exec $MYSQL_BINLOG --start-position=$init_slave_binlog_pos --stop-position=$end_slave_binlog_pos $MYSQLD_DATADIR/$slave_binlog_file > $mysqlbinlog_out

--let $assert_file= $mysqlbinlog_out
--let $assert_text= Non-transactional event should have been written to binary log
--let $assert_select=GTID $master_pos
--let $assert_count= 1
--source include/assert_grep.inc

--let $assert_text= Non-transactional event should have rolled back
--let $assert_select=ROLLBACK\$
--let $assert_count= 1
--let $assert_only_after= GTID $master_pos
--source include/assert_grep.inc

--remove_file $mysqlbinlog_out

--connection master
--source include/save_master_gtid.inc
--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc



--echo #
--echo # Cleanup
--connection master
DROP TABLE ti, tm, ti2, tm2;
--eval SET @@global.binlog_direct_non_transactional_updates= $old_binlog_direct
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
--eval set @@global.slave_parallel_threads=$old_threads
--eval set @@global.slave_domain_parallel_threads=$old_domain_threads
--eval set @@global.slave_parallel_mode=$old_slave_mode
--source include/start_slave.inc

--source include/rpl_end.inc

--echo # End of tests

